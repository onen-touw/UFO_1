#pragma once

#include "UFO_DataStorage.h"
#include "UFO_TaskMinimal.h"
#include "MPU6050_6Axis_MotionApps20.h"
#include "../UFO_math/MadgwickAHRS.h"

#define UFO_MPU_ADDR 0x68

float q[4] = {1.0f, 0.0f, 0.0f, 0.0f};

float GyroMeasError = PI * (40.0f / 180.0f);     // gyroscope measurement error in rads/s (start at 60 deg/s), then reduce after ~10 s to 3
float beta = sqrt(3.0f / 4.0f) * GyroMeasError;  // compute beta
float GyroMeasDrift = PI * (2.0f / 180.0f);      // gyroscope measurement drift in rad/s/s (start at 0.0 deg/s/s)
float zeta = sqrt(3.0f / 4.0f) * GyroMeasDrift;
float pitch, yaw, roll;
float deltat = 0.0f;  

void MadgwickQuaternionUpdate(float ax, float ay, float az, float gx, float gy, float gz)
        {
            float q1 = q[0], q2 = q[1], q3 = q[2], q4 = q[3];         // short name local variable for readability
            float norm;                                               // vector norm
            float f1, f2, f3;                                         // objetive funcyion elements
            float J_11or24, J_12or23, J_13or22, J_14or21, J_32, J_33; // objective function Jacobian elements
            float qDot1, qDot2, qDot3, qDot4;
            float hatDot1, hatDot2, hatDot3, hatDot4;
            float gerrx, gerry, gerrz, gbiasx, gbiasy, gbiasz;        // gyro bias error

            // Auxiliary variables to avoid repeated arithmetic
            float _halfq1 = 0.5f * q1;
            float _halfq2 = 0.5f * q2;
            float _halfq3 = 0.5f * q3;
            float _halfq4 = 0.5f * q4;
            float _2q1 = 2.0f * q1;
            float _2q2 = 2.0f * q2;
            float _2q3 = 2.0f * q3;
            float _2q4 = 2.0f * q4;
            float _2q1q3 = 2.0f * q1 * q3;
            float _2q3q4 = 2.0f * q3 * q4;

            // Normalise accelerometer measurement
            norm = sqrt(ax * ax + ay * ay + az * az);
            if (norm == 0.0f) return; // handle NaN
            norm = 1.0f/norm;
            ax *= norm;
            ay *= norm;
            az *= norm;
            
            // Compute the objective function and Jacobian
            f1 = _2q2 * q4 - _2q1 * q3 - ax;
            f2 = _2q1 * q2 + _2q3 * q4 - ay;
            f3 = 1.0f - _2q2 * q2 - _2q3 * q3 - az;
            J_11or24 = _2q3;
            J_12or23 = _2q4;
            J_13or22 = _2q1;
            J_14or21 = _2q2;
            J_32 = 2.0f * J_14or21;
            J_33 = 2.0f * J_11or24;
          
            // Compute the gradient (matrix multiplication)
            hatDot1 = J_14or21 * f2 - J_11or24 * f1;
            hatDot2 = J_12or23 * f1 + J_13or22 * f2 - J_32 * f3;
            hatDot3 = J_12or23 * f2 - J_33 *f3 - J_13or22 * f1;
            hatDot4 = J_14or21 * f1 + J_11or24 * f2;
            
            // Normalize the gradient
            norm = sqrt(hatDot1 * hatDot1 + hatDot2 * hatDot2 + hatDot3 * hatDot3 + hatDot4 * hatDot4);
            hatDot1 /= norm;
            hatDot2 /= norm;
            hatDot3 /= norm;
            hatDot4 /= norm;
            
            // Compute estimated gyroscope biases
            gerrx = _2q1 * hatDot2 - _2q2 * hatDot1 - _2q3 * hatDot4 + _2q4 * hatDot3;
            gerry = _2q1 * hatDot3 + _2q2 * hatDot4 - _2q3 * hatDot1 - _2q4 * hatDot2;
            gerrz = _2q1 * hatDot4 - _2q2 * hatDot3 + _2q3 * hatDot2 - _2q4 * hatDot1;
            
            // Compute and remove gyroscope biases
            gbiasx += gerrx * deltat * zeta;
            gbiasy += gerry * deltat * zeta;
            gbiasz += gerrz * deltat * zeta;
            gx -= gbiasx;
            gy -= gbiasy;
            gz -= gbiasz;
            
            // Compute the quaternion derivative
            qDot1 = -_halfq2 * gx - _halfq3 * gy - _halfq4 * gz;
            qDot2 =  _halfq1 * gx + _halfq3 * gz - _halfq4 * gy;
            qDot3 =  _halfq1 * gy - _halfq2 * gz + _halfq4 * gx;
            qDot4 =  _halfq1 * gz + _halfq2 * gy - _halfq3 * gx;

            // Compute then integrate estimated quaternion derivative
            q1 += (qDot1 -(beta * hatDot1)) * deltat;
            q2 += (qDot2 -(beta * hatDot2)) * deltat;
            q3 += (qDot3 -(beta * hatDot3)) * deltat;
            q4 += (qDot4 -(beta * hatDot4)) * deltat;

            // Normalize the quaternion
            norm = sqrt(q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4);    // normalise quaternion
            norm = 1.0f/norm;
            q[0] = q1 * norm;
            q[1] = q2 * norm;
            q[2] = q3 * norm;
            q[3] = q4 * norm;
        }




// WARNING!!!
//  ESP_DRAM_LOGx for interraption (maybe for IRAM_ATTR also )
void /*IRAM_ATTR*/ UFO_Task_IMU(void *arg)
{
    UFO_SendToFunckMinimal *data = (UFO_SendToFunckMinimal *)arg;
    delay(10);
    Serial.print("Task created: ");
    Serial.println(data->name);
    Serial.print("\tupdate time:");
    Serial.println(data->updTime);

    delay(10);
    MPU6050 mpu;
    mpu.initialize();
    Madgwick _filter;
    _filter.begin(25);

    // delay(100);
    // mpu.CalibrateAccel(6);
    // mpu.CalibrateGyro(6);
    delay(100);

    float ypr[3]; // [yaw, pitch, roll]   yaw/pitch/roll container and gravity vector
    int16_t ax = 0,
            ay = 0,
            az = 0,
            gx = 0,
            gy = 0,
            gz = 0;
    float   axReal = 0,
            ayReal = 0,
            azReal = 0,
            gxReal = 0,
            gyReal = 0,
            gzReal = 0;
    delay(10);

    while (true)
    {
        if (!UFO_IMUData.locked)
        {
            mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);

            axReal = ax * 2 / 32768.0;
            ayReal = ay * 2 / 32768.0;
            azReal = ay * 2 / 32768.0;

            gxReal = gx * 250.0 / 32768.0;
            gyReal = gy * 250.0 / 32768.0;
            gzReal = gz * 250.0 / 32768.0;

            MadgwickQuaternionUpdate(ax, ay, az, gx*PI/180.0f, gy*PI/180.0f, gz*PI/180.0f);
            deltat = (25/1000000.0f);
            yaw = atan2(2.0f * (q[1] * q[2] + q[0] * q[3]), q[0] * q[0] + q[1] * q[1] - q[2] * q[2] - q[3] * q[3]);
            pitch = -asin(2.0f * (q[1] * q[3] - q[0] * q[2]));
            roll = atan2(2.0f * (q[0] * q[1] + q[2] * q[3]), q[0] * q[0] - q[1] * q[1] - q[2] * q[2] + q[3] * q[3]);
            pitch *= 180.0f / PI;
            yaw *= 180.0f / PI;
            roll *= 180.0f / PI;
            // Serial.print("ax: ");
            // Serial.print(axReal);
            // Serial.print(";\t ay:");
            // Serial.print(ayReal);
            // Serial.print(";\t az:");
            // Serial.print(azReal);
            // Serial.print(";\t gx: ");
            // Serial.print(gxReal);
            // Serial.print(";\t gy: ");
            // Serial.print(gyReal);
            // Serial.print(";\t gz: ");
            // Serial.println(gzReal);

            
            Serial.print(">yaw:");

            Serial.println(yaw);
            // Serial.println(ypr[0] * 180 / M_PI);
            Serial.print(">pitch:");
            Serial.println(pitch);
            // Serial.println(ypr[1] * 180 / M_PI);
            Serial.print(">roll:");
            Serial.println(roll);
            // Serial.println(ypr[2] * 180 / M_PI);
        }
        delay(data->updTime); // (this delay is neccesary for yeild)
    }

    Serial.print("Task terminated: ");
    Serial.println(data->name);

    delete data;
    vTaskDelete(NULL);
}

// void loop()
// {
//     // If data ready bit set, all data registers have new data
//     if (readByte(MPU6050_ADDRESS, INT_STATUS) & 0x01)
//     {                              // check if data ready interrupt
//         readAccelData(accelCount); // Read the x/y/z adc values
//         getAres();

//         // Now we'll calculate the accleration value into actual g's
//         ax = (float)accelCount[0] * aRes; // get actual g value, this depends on scale being set
//         ay = (float)accelCount[1] * aRes;
//         az = (float)accelCount[2] * aRes;

//         readGyroData(gyroCount); // Read the x/y/z adc values
//         getGres();

//         // Calculate the gyro value into actual degrees per second
//         gx = (float)gyroCount[0] * gRes; // get actual gyro value, this depends on scale being set
//         gy = (float)gyroCount[1] * gRes;
//         gz = (float)gyroCount[2] * gRes;

        
//     }

//     Now = micros();
//     deltat = ((Now - lastUpdate) / 1000000.0f); // set integration time by time elapsed since last filter update
//     lastUpdate = Now;
//     //    if(lastUpdate - firstUpdate > 10000000uL) {
//     //      beta = 0.041; // decrease filter gain after stabilized
//     //      zeta = 0.015; // increase gyro bias drift gain after stabilized
//     //    }
//     // Pass gyro rate as rad/s
//     MadgwickQuaternionUpdate(ax, ay, az, gx * PI / 180.0f, gy * PI / 180.0f, gz * PI / 180.0f);

//     // Serial print and/or display at 0.5 s rate independent of data rates
//     delt_t = millis() - count;
//     if (delt_t > 500)
//     { // update LCD once per half-second independent of read rate
//         digitalWrite(blinkPin, blinkOn);
//         /*
//             Serial.print("ax = "); Serial.print((int)1000*ax);
//             Serial.print(" ay = "); Serial.print((int)1000*ay);
//             Serial.print(" az = "); Serial.print((int)1000*az); Serial.println(" mg");

//             Serial.print("gx = "); Serial.print( gx, 1);
//             Serial.print(" gy = "); Serial.print( gy, 1);
//             Serial.print(" gz = "); Serial.print( gz, 1); Serial.println(" deg/s");

//             Serial.print("q0 = "); Serial.print(q[0]);
//             Serial.print(" qx = "); Serial.print(q[1]);
//             Serial.print(" qy = "); Serial.print(q[2]);
//             Serial.print(" qz = "); Serial.println(q[3]);
//         */
//         // Define output variables from updated quaternion---these are Tait-Bryan angles, commonly used in aircraft orientation.
//         // In this coordinate system, the positive z-axis is down toward Earth.
//         // Yaw is the angle between Sensor x-axis and Earth magnetic North (or true North if corrected for local declination, looking down on the sensor positive yaw is counterclockwise.
//         // Pitch is angle between sensor x-axis and Earth ground plane, toward the Earth is positive, up toward the sky is negative.
//         // Roll is angle between sensor y-axis and Earth ground plane, y-axis up is positive roll.
//         // These arise from the definition of the homogeneous rotation matrix constructed from quaternions.
//         // Tait-Bryan angles as well as Euler angles are non-commutative; that is, the get the correct orientation the rotations must be
//         // applied in the correct order which for this configuration is yaw, pitch, and then roll.
//         // For more see http://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles which has additional links.
       

//         blinkOn = ~blinkOn;
//         count = millis();
//     }
// }
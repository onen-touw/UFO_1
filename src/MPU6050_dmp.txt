#pragma once

#include "UFO_DataStorage.h"
#include "UFO_TaskMinimal.h"
#include "MPU6050_6Axis_MotionApps20.h"
#include "../UFO_math/MadgwickAHRS.h"

// WARNING!!!
//  ESP_DRAM_LOGx for interraption (maybe for IRAM_ATTR also )
void /*IRAM_ATTR*/ UFO_Task_IMU(void *arg)
{
    UFO_SendToFunckMinimal *data = (UFO_SendToFunckMinimal *)arg;
    delay(10);
    Serial.print("Task created: ");
    Serial.println(data->name);
    Serial.print("\tupdate time:");
    Serial.println(data->updTime);
    delay(10);



    MPU6050 mpu;
    mpu.initialize();
    mpu.dmpInitialize();
    
    mpu.setXGyroOffset(800);
    mpu.setYGyroOffset(100);
    mpu.setZGyroOffset(500);
    mpu.setZAccelOffset(1788); // 1688 factory default for my test chip

    Serial.println("CalibStart");
    mpu.CalibrateAccel(6);
    mpu.CalibrateGyro(6);
    Serial.println("CalibEnd");

    uint8_t fifoBuffer[64]; // FIFO storage buffer
	int16_t packetSize = mpu.dmpGetFIFOPacketSize();
    Quaternion q;           // [w, x, y, z]         quaternion container
    VectorFloat gravity;    // [x, y, z]            gravity vector

    delay(100);

    mpu.setDMPEnabled(true);
    
    delay(100);

    float ypr[3]; // [yaw, pitch, roll]   yaw/pitch/roll container and gravity vector

    while (true)
    {
        if (!UFO_IMUData.locked)
        {
		        mpu.dmpGetCurrentFIFOPacket(fifoBuffer);
				mpu.dmpGetQuaternion(&q, fifoBuffer);
				mpu.dmpGetGravity(&gravity, &q);
				mpu.dmpGetYawPitchRoll(ypr, &q, &gravity);


            Serial.print(">yaw:");
            // Serial.println(yaw);
            Serial.println(ypr[0] * 180 / M_PI);
            Serial.print(">pitch:");
            // Serial.println(pitch);
            Serial.println(ypr[1] * 180 / M_PI);
            Serial.print(">roll:");
            // Serial.println(roll);
            Serial.println(ypr[2] * 180 / M_PI);
        }
        delay(data->updTime); // (this delay is neccesary for yeild)
    }

    Serial.print("Task terminated: ");
    Serial.println(data->name);

    delete data;
    vTaskDelete(NULL);
}
